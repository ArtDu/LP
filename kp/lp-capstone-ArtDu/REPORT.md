# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Дубинин А. О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*

## Введение

За время выполнения курсового проекта я изучил обширный пласт логического программирования, применил многие навыки полученные при выполнении лабораторных работ, например методы поиска и естественно-языковой интерфейс. Также я познакомился с таким форматом как GedCom, по сути, аналогов для представления генеалогических деревьев не существует. Он хорошо развит и документирован.

## Задание

 1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com 
 2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: parents(потомок, отец, мать)
 3. Реализовать предикат проверки/поиска vi. Теща
 4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
 5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы. 

## Получение родословного дерева

Моё родословное дерево получилось не сильно большим, поскольку сколько-нибудь достоверные данные было достать сложно. Моя семья разбросана по всей России и связи между родственниками поддерживались плохо.

## Конвертация родословного дерева

Для конвертации родословного дерева я использовал язык Python, поскольку он удобен для работы с текстом и идеально подходит для подобных задач -- быстро написать программу, который ты больше никогда не воспользуешься. Главным принципом моей программы является построчное считывание файла с запоминание id конкретного человека, затем по этим id создание семей. 
Генерация предиката child:
```
while (line[1] == 'CHIL'):
      if len(wife)>0 and len(husbando)>0:
        print("parents({0}, {1},{2}).".format(people[line[2]], husbando , wife))
      line = f.readline().split()
```


## Предикат поиска родственника

Предикат поиска родственника, в моём случае теща, реализован следующим образом:
```
%% (Теща, мужчина)
motherInLaw(Z,X) :- parents(_,X,Y), parents(Y,_,Z), !.
```
Для начала ищем жену, а потом мать жены. 
```
?- motherInLaw(Z,"Дубинин Олег").
Z = "Юминова Нина".

?- motherInLaw(Z,"Юминов Владимир").
Z = "Сторожева Анастасия".

```

## Определение степени родства

`relative(Родство, X, Y)` Кто Y для X? Определение родства двух конкретных индивидуумов.

При определении произвольной степени родства сперва проверяются тривиальные случаи, например
```
relative(son, X, Y, _):-parents(Y,_,X), parents(_,Y,_),!.
```
когда все они пройдены, необходимо искать более сложные решения для это используется предикат
```
relative(Surf-Deep, X, Y, N):-
	N = 'deep',
	relative(Deep, X, Intermediate, 'deep'),
	not(X = Intermediate),
	relative(Surf, Intermediate, Y, 'surface'),
	not(Y = Intermediate),
	not(X = Y).

```
Суть его заключается в следующем: определяем для Х человека, который является каким либо родственником ему, и пытаемся определить степень родства этого человека для Y. Чтобы избежать циклов и малочитаемых сложных решений на ранних стадиях поиска, поиск для Y осуществляется поверхностно, без захода в рекурсивную функцию опеределения родства. Полнота вывода от этого не страдает. Бесконечное количество ответов от такого решения оптимизации не уменьшилось. Однако удобочитаемость и простота ответов повысилась, поскольку подобный поиск очень похож на обход графа с итерационным спуском, величина спуска равна 1, таким спуском обусловливается последовательное увеличения количества слов в ответе.
## Естественно-языковый интерфейс

Естественно языковой интерфейс реализован для двух ситуаций: Сколько (тип родственника) имеет человек? и проверки истинности утверждения: Маша сестра пети? и ответа, сообщающего о том, что запрос пользователя не распознан.
Определение смысла происходит с помощью разбора предложения на значащие части, определения по ним типа запроса и последующего его анализа. 

Для определения типа вопроса используется словарь, строки в нём имеют вид
```
  'is':type('approve'),
   'How':'many':type('count'),
    'Have':type('having'),
```
по этим значащим частям программа вычленияет структуру запроса и пытается определить, что является искомым именем, а что типом родственной связи. Поскольку в естесственном языке используется множественное число при вопросах о количестве, то также необходим словарь для определения числа слова:
```
gen_many(F):-
  F=[
  fathers:father,
  mothers:mother,
  ...
```
Проверка на существование человека:
```
name(X):-
  parents(X,_,_).
name(X):-
  parents(_,X,_).
name(X):-
  parents(_,_,X).

```
Выбираем понятное для программы единственное число:
```
many(S, S1):-
  gen_many(Many_list),
  member(S:S1, Many_list).

%множественное число
gen_many(F):-
  F=[
  fathers:father,
  mothers:mother,
  daugthers:daugther,
  sons:son,
  sisters:sister,
  brothers:brother,
  wives:wife,
  husbands:husband,
  father:father,
  mother:mother,
  daugther:daugther,
  son:son,
  sister:sister,
  brother:brother,
  wife:wife,
  husband:husband
  ].

```
Когда структура становиться понятна программе, производится запрос к ранее реализованомму предикату(relative), обработка его ответа и вывод на экран. Подсчёт количества:
```
...
    setof(N,relative(Rel,E,N),L),
    length(L,N1),
    write("There are "), write(N1),
    write(" "),
    write(C),nl,
    write(L), nl, !.
```
и определение истинности:
```
relative(Rel,B,E),
  write("Yes, it is"), nl, !.
  
...
  write("No, this is wrong"), nl,!.
```

Обработка непонятых запросов:
```
a_phrase(_):- write("Can not understand question. Please, be more specific"), nl.
```

Использование:
```
?- a_phrase(['How','many','fathers','does',"Дубинин Артем",'has']).
There are 1 fathers
[Дубинин Олег]
true.

?- a_phrase(['Does',"Дубинин Борис",'has','son',"Дубинин Олег"]).
Yes, it is
true.

?- a_phrase(['Does',"Юминов Владимир",'has','daugther',"Дубинина Евгения"]).
Yes, it is
true.


```

## Выводы

Курсовой проект заставил меня задуматся над серьёзным изучением логических языков программирования. При выполнении 5-го задания курсовой и 4-го лабораторной работы я познакомился с анализом естественных языков. До этого момента естественный язык казался мне непостижимо сложным, неопределенным и творческим, таким, каким компьютер не сможет овладеть, хотя сейчас сопоставляя русский язык и абстракции в языках программирования, я подумал, что быть может вполне реально научить машину естественному языку, если она уже владеет такими сложными математическими концепциями и абстракциями.