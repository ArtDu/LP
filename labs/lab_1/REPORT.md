# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Дубинин А. О.

## Результат проверки

| Преподаватель | Дата | Оценка |
|-------------------|--------------|---------------|
| Сошников Д.В. | | |
| Левинская М.А.| |4|

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Список(или List) в Прологе можно представить как бинарное дерево и дать следующее рекурсивное определение: пустой список является списком, список состоит из элемента (головы) и другого списка (хвоста). Такое представление показывает каким образом чаще всего происходит работа со списками, обрабатывается голова и рекурсивно вызывается та же функция для хвоста, пока он не будет пустым. 

От принятых в императивных языках подходов к хранению данных списки Пролога отличаются, в первую очередь, произвольным типом элементов, такое свободное отношение к типам редко в императивных языках. Как было сказано выше списки Пролога очень похожи на бинарные деревья, с тем допущением, что каждый узел имеет лист. В SWI-Prolog, в частности, присутствует большой набор встроенных функций для обработки списков, что наталкивает на мысль о схожести списков и векторов (вектор -- динамический массив): они часто меняют количество содержащися элементов и действия чаще всего производятся с крайними элементами (функции pop и push у вектора).

## Задание 1.1: Предикат обработки списка

`truncation(List,Length,Result)` Усечение списка до указанной длины с использованием стандартный предикатов

`truncation2(List,Length,Result)` Усечение списка до указанной длины без стандартных предикатов

Примеры использования:
```
?- truncation([1,4,5,6,78,0,4],3,Result).
Result = [1, 4, 5].

?- truncation2([1,2,3,4,5,6],5,Result).
Result = [1, 2, 3, 4, 5].

```

Реализация:
```
truncation(List,Length,Result):-append(Result, _, List), length(Result, Length), !.
```
С помощью append'а рассматриваем все возможности разбиения списка, а с помощью length находим разбиение нужной длины.
```
truncation2(_,0,[]).
truncation2([ListHead|ListTail],Length,[ListHead|ResultTail]):-
	Length1 is Length - 1,
	truncation2(ListTail, Length1, ResultTail),!.
```
Рекурсивно задаем, пока длина не нуль и результат не пуст, убираем один левый элемент результата и изначального списка, при условии, что они равны, и уменьшаем длину на единицу.

## Задание 1.2: Предикат обработки числового списка

`minElemPos(List,Pos)` Вычисление позиции минимального элемента в списке с использованием стандартных предикатов

`minElemPos2(List,Pos)` Версия без использования стандартных предикатов

Примеры использования:
```
?- minElemPos([5,4,3,2,1,2,3,4,5],Pos).
Pos = 4.

?- minElemPos2([1,2,-99,3],Pos).
Pos = 2.

```

Реализация:
```
minElemPos(List,Pos):-min_list(List,MinElem), nth0(Pos,List,MinElem), !.
```
С помощью min_list находим минимальный элемент, с помощью nth0 находим позицию этого элемента.
```
minElemPos2(List,Pos):-
    minForList(List,Min),
    minPosForList(List,0,Pos,Min),!.

minPosForList([Min|_],Pos,Pos,Min).
minPosForList([_|Ls],Pos1,Pos,Min):-
    Pos2 is Pos1+1,
    minPosForList(Ls,Pos2,Pos,Min).

minForTwo(X,Y,X):- X=<Y, !.
minForTwo(X,Y,Y):- X>Y.

minForList([L|Ls], Min) :-
    minForList(Ls, L, Min).

minForList([], Min, Min).
minForList([Head|Tail], Min0, Min):-
    Min1 is min(Head,Min0),
    minForList(Tail, Min1, Min).
```
Для поиска без использование реализуем поиск минимального элемента в списке, для этого реализуем выбор минимального из двух элементов, использовав стандартное сравнение элементов языка пролог. Затем, напишем поиск позиции минимального элемента.

## Задание 1.3: Пример совместного использования
`truncationSpec(List,Result)` Предикат, который отсекает список до минимального элемента.

Примеры использования:
```
?- truncationSpec([1,2,-99,3],Result).
Result = [1, 2].

?- truncationSpec([-99,1,2,3,4],Result).
Result = [].

```

Реализация:
```
truncationSpec(List,Result):-
        minElemPos(List,Pos),truncation(List,Pos,Result).
```
Находим позицию позицию минимального элемента и используем её, как длину для отсечения.

## Задание 2: Реляционное представление данных

Термин «реляционный» означает, что теория основана на понятии отношениях (relation) между объектами. Для удовлетворения запроса к таким данным необходимо провести анализ отношений между ними. Таким образом задачей программиста является создание программы, позволяющей осуществлять этот анализ. Самым главным преимуществом такого представления данных является приближенность к реальному миру. Отношения являются логическими и абстрактными, а не физически хранимыми структурами.

Моё представление не похоже на хорошую таблицу из баз данных, данные об оценках в таблице со студентами можно было разместить в отдельной таблице. Таблица занимает немного места: в каждой строке со студентом присутствует список с оценками. Но в тоже время, просмотр таблицы не удобен. Поиск по таблицы будет не удобен так как при сопостовлении каких-либо придметов приходится пробегать по всем ученикам и у каждого ученика нужно пробегать по оценкам.
Да, наверное компакность этой таблицы будет иметь плюсы по скорости, при определенных запросах к базе данных.

Данные: 3 (three.pl)
Вариант: 3
- Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
- Для каждого предмета, найти количество не сдавших студентов
- Для каждой группы, найти студента (студентов) с максимальным средним баллом

### Задание 2.1: Для каждого студента, найти средний балл, и сдал ли он экзамены или нет

`averageMark(Stud,Mark)` Для каждого студента, найти средний балл

`passExams(Stud)` Сдал ли студент экзамены

Примеры использования:
```
?- averageMark('Петров',X).
X = 4.

?- averageMark('Петровский',X).
X = 3.6666666666666665.

?- averageMark(X,4).
X = 'Петров' ;
X = 'Иванов' ;
X = 'Сидоров' ;
X = 'Биткоинов' ;
X = 'Программиро' ;
X = 'Круглотличников'.

?- passExams('Петров').
true.

?- passExams('Азурин').
false.

```

Реализация:
```
%2.1 Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
%(Студент, Средняя оценка)
averageMark(Stud,Mark):-
	student(_,Stud,Z),
	sum(Z, Sum),
	length(Z,Len),
	Mark is Sum / Len.
	
%Cумма всех элементов в списке
%(Список, Сумма)
sum([grade(_, H)|T],N):-
	sum(T,N1),
	N is N1+H.
sum([],0).

%Сдал ли студент экзамены
%Если хотя бы одна двойка, то false
%(Студент)
passExams(Stud):-
	student(_,Stud,Marks),
	not(member(grade(_,2),Marks)).

```
Для поиска средней оценки находяться все оценки студента, суммируются  и cумма делится на их количество.

Сдал ли студент экзамен? Ищутся все его оценки и проверятся наличие среди них двоек.

### Задание 2.2:  Для каждого предмета, найти количество не сдавших студентов

`countOfFailed(Subj,N)` Для каждого предмета, найти количество не сдавших студентов

Примеры использования:
```
?- countOfFailed('Математический анализ',X).
X = 3.

?- countOfFailed('Английский язык',X).
X = 2.

```

Реализация:
```
%2.2 Для каждого предмета, найти количество не сдавших студентов
%(Предмет, количество)
countOfFailed(Subj,N):-
	subject(Ss,Subj),
	findall(A,(student(_,_,A),gradeInList(A,Ss)),AllMarks),
	length(AllMarks,N).

gradeInList([grade(Subj,2)|_],Subj).
gradeInList([_|Tail],Subj):-
	gradeInList(Tail,Subj).
```
Для предмета находится множество (без повторений!) учеников у которых двойка по этому предмету. Длина этого списка-множества искомое.

### Задание 2.3: Для каждой группы, найти студента (студентов) с максимальным средним баллом

`bestStudent(Group,N)` Для каждой группы, найти студента (студентов) с максимальным средним баллом

Примеры использования:
```
?- bestStudent(101,L).
L = ['Безумников', 'Густобуквенникова'].

?- bestStudent(102,L).
L = ['Азурин'].

?- bestStudent(103,L).
L = ['Вебсервисов'].

?- bestStudent(104,L).
L = ['Фулл'].

```

Реализация:
```
%2.3 Для каждой группы, найти студента (студентов) с максимальным средним баллом
%(Группа, Список учеников с максимальным средним баллом)
bestStudent(Group,N):-
  %собираем список со всеми средними оценками
  findall(Mark, (student(Group,Stud,_), averageMark(Stud,Mark)),Marks),
  %находим мвксимальную из них
  max(Marks,Max),
  %составляем список из всех студентов имеющих такую оценку
  findall(A,(student(Group,A,_), averageMark(A,M), M==Max), N), !.

%Нахождение максимального из положительного числового списка
%(Список, максимум)
max([],0).
max([H|T],N):-
  max(T,B),
  H =< B,
  N is B.
max([H|T],N):-
  max(T,B),
  H >= B,
  N is H.
```
Сперва ищется максимальная средняя оценка по группе: находиться список со всеми оценками и выделяется максимальная. Затем собирается список со всеми учениками, имеющими эту максимальную оценку.


## Выводы

Самое главное отличие Пролога от привычных мне императивных языков программирования то, что программист описывает задачу, которую Пролог, по сути, решает сам. Тексты программ на Прологе удивительно просто читать, и в тоже время их написание сложный процесс, который заставляет программиста мыслить глобально, логически, не пошагово.
Примечательно, что иногда Пролог находит нетривиальное решение задачи, которое программист и не представлял увидеть среди ответов, но в то же время удовлетворяющее условиям задачи. 
Во время составления программ я немало времени уделил использованию трассировки, это помогло мне лучше понять логику Пролога, как он думает, и вникнуть в механизм бэктрекинга. 
Пролог, для меня, оказался неожиданно мощным средством решения задач, я продолжу более глубокое изучение его механизмов.
