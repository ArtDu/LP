#№ Отчет по лабораторной работе №4
## по курсу "Логическое программирование"

## Обработка естественного языка

### студент: Дубинин А. О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Естественный язык – очень сложная система с неочевидной и гибкой структурой. Любой анализ естественного языка сводиться к нескольким этапам: предварительный анализ (поиск границ слов и предложений), морфологический анализ (установление словарных форм слов и приписывание им морфологических признаков), синтаксический анализ (зависимости между словами), семантический анализ (смысл предложения или отдельных слов). 
Грамматика описывает закономерности устройства языка, но она имеет описательный характер и, к сожалению, не всегда содержит явные и чёткие правила формирования предложений. Самой главной задачей анализа естественного языка является выявление закономерностей. В этом используется два подхода -- работа эксперта-лингвиста и автоматическое исследование размеченных данных.

Пролог удобен для таких задач, т.к. на нём удобно описывать грамматику, она понятна человеку, который читает код, и в то же время человеку, который его пишет.

Для искусственного языка характерна строгая структура и конкретные правила синтаксиса, семантики и пр. Обработка искусственного языка проводится транслятором (компилятором), который обо всех правилах осведомлен и не предполагает за собой эвристики.

Насколько Пролог эффективен для анализа естественных языков вопрос спорный, поскольку в наше время чаще всего используется не языки логического программирования, а второй подход -- автоматическое обучение на больших объёмах данных, где определение грамматики предоставлено программе, и человеку невозможно понять закономерности которые вывела программа. 

## Задание

6. Реализовать синтаксический анализатор логического выражения и вычислить
его значение. В выражение допустимы операции отрицания, дизъюнкции,
конъюнкции, следования. {~, V, &, =>}. Истинные считаются только термы
заданы фактами вида
true(river_volga).
true(pupil_vasia).
************
`Запрос: ?-calculate(‘(‘,false,‘V’, river_volga,’)’ & true], X).
Результат: X=true.`

## Принцип решения

Принцип решения строится на прохождении списка и выявлении простых форм утверждений.
То есть, простые формы {~, V, &, =>} данных операции будут представлять такой шаблон:
A <operator> B, где A,B - простые выражения. Мы вычисляем ответ на эту форму в виде true или false и подставляем в список для дальнейшего рекуривного вычисления. 

### Пример вычисления простой формы:
```
analyzer([A,'&',B | T], Res):-
	true(A),
	true(B),
	valid(A),
	valid(B),
	analyzer([true|T],Res),
	!.

analyzer([A,'&',B | T], Res):-
	valid(A),
	valid(B),
	analyzer([false|T],Res).
```

В первом предикате мы проверяем на истинность выражение коньюнкции. Для начала мы проверяем истины ли А и Б, затем валидность данных А и Б, то есть не является ли А или Б случайно оператором. При выполнении всех требовании возращаем true, иначе, при валидных данных false.
### Проверка истинности и валидации:
```
true(river_volga).
true(pupil_vasya).
true(true).

valid(X):-
	X \= '(',
	X \= ')',
	X \= '&',
	X \= '=>',
	X \= '~',
	X \= 'V'.

```

Если мы не можем найти простую форму то, мы рекурсивно пропускаем один знак, подразумевая вложенную структуру A & B, где B предсталяет собой сложную структуру, например ~(C=>D).
### Рекурсивный обход:
```
analyzer([A|[B|T]],Res):-
	% so the tail has to be non empty
	analyzer([B|T],Y),
	% analyzer can not complete args
	[B|T] \= Y,
	analyzer([A|Y],Res),!.

```
При подсчете простых рекурсивно возвращаемся к сложным, которые при схлопывании простых бинарных в форм в true или false, начнут считаться.

## Результаты

```
?- calculate(['(','river_volga','&',true,')','&',true],RES).
RES = true.

?- calculate([false,'&','(','(','river_volga','&',true,')','&',true,')'],RES).
RES = false.

```

## Выводы

При работе с искусственным языком, я понял, что для таких языков нужна строгость решения. Работая с прологом, особенно, ведь он переберает различные подстановки, зависимо от написаных предикатов и может появиться вариант предложения, который непредусмотрен программой. Так было со мной и мне часто приходилось проходить дебагером в поиске того самого недочета. 

Но в тоже время это самый главный плюс пролога, перебором легко решаются задачи с искусственным и естественным языком.

Пролог был бы удобен и для решения задач грамматического разбора: реализация правил перехода довольно очевидна и проста.

Возможно ли таким методом формализовать весь русский язык? Я думаю, что нет. Создание правил осложняется многими аспектами, например, анафорами (распознаванием, что имеется в виду при использовании местоимений), свободным порядком слов, да и просто богатством естественного, в частности русского, языка. Структуризация такого огромного массива данных представляется нереальной для человека. Также стоит учитывать изменчивость языка: будет ли человек успевать учитывать изменения при разработке такой глобальной системы?

Решение подобной проблемы приводит к попытке автоматизации этой структуризации. Очень привлекательными в таком плане выглядят нейронные сети, в частности, рекуррентные нейронные сети. Разработки и исследования в этой области очень активны сейчас.

Хотя определенного успеха в распознавании естественного языка человечество уже добилось. Например, интернет-поисковики. Их интерфейс реализован как упрощенная модель естественного языка. Или автоматические переводчики, которые выдают более менее хорошие результаты для простых конструкций.




