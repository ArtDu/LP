#№ Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Дубинин А. О.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Какие задачи удобным образом решаются методом поиска в пространстве состояний? 
Почему Prolog оказывается удобным языком для решения таких задач?

Пространство состояний представляет собой набор ситуаций. Из каждого состояния возможно перейти в другое состояние путем каких-то действий. Поэтому удобно использовать такой метод, когда у нас есть два заданных состояния -- начальное и конечное, и число всевозможных состояний конечно. Если представить такое пространство как граф, где вершинами являются состояния, то путь от начальной вершины до конечной будет показывать набор состояний, являющийся решением задачи. В итоге, такие задачи сводятся к задаче поиска в графе. Основные стратегии решения такой задачи, которые я использовал в своей работе, -- поиск в глубину, поиск в ширину и поиск с итеративным погружением.

Для представление графа в программировании обычно используют матричное представление, где граф задается своей матрицей смежности. В Прологе граф описывается предикатами путем явного перечисления всех дуг в виде пар вершин. Задание графа при помощи дуг является более гибким, чем матрица смежности, поскольку дуги могут задаваться не только явным перечислением, но и при помощи правил, что позволяет нам описывать очень сложные и большие графы, для которых матричное представление нерационально и вообще не всегда возможно.

## Задание

7. Вдоль доски расположены лунки, в каждой из которых лежит черный
или белый шар. Одним ходом можно менять местами два соседних
шара. Добиться того, чтобы сначала шли белые шары, а за ними -
черные. Решить задачу за наименьшее число ходов.

## Принцип решения

Основной принцип решения задачи состоит в следующем: идем по списку, перебирая по 2 шара из списка, проверяем лежат ли эти шары в правильной последовательности, если нет, то меняем их местами. Я использовал 3 алгоритма поиска: поиск в глубину, поиск в ширину и поиск с итеративным погружением. Они отражены в предикатах search_dpth, search_bdth и search_id соответсвенно.

Рассмотрим часть, общую для всех трех алгоритмов. Предикат prolong нужен, чтобы продлить все пути в графе, предотвращая зацикливания. 
```prolog
prolong([X|T],[Y,X|T]):-
    move(X,Y),
    \+ member(Y,[X|T]).
```

Предикат move отражает переход между состояниями в графе. Во втором правиле проходим по списку, представляющему одно состояние, меняем элементы, стоящие не на своем месте, что позволяет получить другое состояние. Предикат between генерирует все целые числа от 0 до Len, т.е. генерируем все числа от 0 до длины списка, затем проверяем, правильно ли стоят элементы с меньшим порядковым индексом относительно элементов с большим порядковым индексом, и меняем эти элементы.
```prolog
move([H|_],Res):-
    move(H,Res).

move(st(L),st(ResL)):-
    length(L,Len),
    Len1 is Len - 1,
    between(0,Len1,A),
    B is A + 1,
    B \= Len,
    check_correct(L,A,B),
    swap_elem(L,A,B,X),
    ResL = X.
```

В предикате check_correct получаем N-ый и M-ый элементы списка. За черным шаром не может лежать белый.
```prolog
check_correct(L,N,M):-
    getNthElem(L,X,N),
    getNthElem(L,Y,M),
    X == black,
    Y == white,
    !.

```

## Результаты

Приведите результаты работы программы: найденные пути, время, затраченное на поиск тем или иным алгоритмом, длину найденного первым пути.

Результат работы:
```prolog
?- search_dpth(st([black,white,black,black,white,black,white]),st([white,white,white,black,black,black,black])).
DFS START
st([black,white,black,black,white,black,white])
st([white,black,black,black,white,black,white])
st([white,black,black,white,black,black,white])
st([white,black,white,black,black,black,white])
st([white,white,black,black,black,black,white])
st([white,white,black,black,black,white,black])
st([white,white,black,black,white,black,black])
st([white,white,black,white,black,black,black])
st([white,white,white,black,black,black,black])
DFS END

TIME IS 0.0011408329010009766

true.

?- search_bdth(st([black,white,black,black,white,black,white]),st([white,white,white,black,black,black,black])).
BFS START
st([black,white,black,black,white,black,white])
st([white,black,black,black,white,black,white])
st([white,black,black,white,black,black,white])
st([white,black,white,black,black,black,white])
st([white,white,black,black,black,black,white])
st([white,white,black,black,black,white,black])
st([white,white,black,black,white,black,black])
st([white,white,black,white,black,black,black])
st([white,white,white,black,black,black,black])
BFS END

TIME IS 0.024989843368530273

true.

?- search_id(st([black,white,black,black,white,black,white]),st([white,white,white,black,black,black,black])).
ITER START
st([black,white,black,black,white,black,white])
st([white,black,black,black,white,black,white])
st([white,black,black,white,black,black,white])
st([white,black,white,black,black,black,white])
st([white,white,black,black,black,black,white])
st([white,white,black,black,black,white,black])
st([white,white,black,black,white,black,black])
st([white,white,black,white,black,black,black])
st([white,white,white,black,black,black,black])
ITER END

TIME IS 0.033393144607543945

true.


```

## Выводы

Все три алгоритма справились со своей задачей, но наиболее эффективно, как видно по результатам времени, оказался поиск в глубину. Он нашел решение быстрее других за наименьшее число шагов. Дело в том, что решение этой задачи тривиально и оно единственное.

Поиск в ширину имеет экспоненциальную сложность как по времени, так и по памяти (на определённых входных данных он может привести к переполнению стека и падению программы, что и произошло со мной на одном из тестов). Поиск в глубину, весьма экономичен по памяти, но в своей наивной реализации неустойчив, и расточителен по времени, как и поиск в ширину. Конечно, нам может повезти, и решение найдется сразу, но на практике это маловероятно.

Для различных задач подходят различные виды поиска, и выбор должен зависеть от цели. В условиях ограничения по памяти лучше использовать поиск в глубину, а с целью поиска кратчайшего пути -- поиск в ширину. Поиск с итеративным углублением хоть и избегает экспоненциальной сложности, но пригоден только для самых простых задач. Конечно, лучше всего использовать эвристический поиск, что чаще и делают на практике. В отличие от использованных мной алгоритмов, эвристический поиск ищет в пространстве состояний более целенаправленно, т.к. имеет функцию оценки состояния. Вообще стратегии использования пространства состояний очень удобны, мне не нужно было для каждого поиска формулировать задачу заново или вносить в формулировку изменения.